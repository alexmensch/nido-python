from builtins import object


class ConfigError(Exception):
    """Exception class for errors generated by the Config class"""

    def __init__(self, msg):
        self.msg = msg
        return

    def __str__(self):
        return repr(self.msg)


class Config(object):
    def __init__(self):
        self._CONFIG = '{}/nido/cfg/config.yaml'.format(_NIDO_BASE)
        self._SCHEMA_VERSION = '1.3'
        self._SCHEMA = {
            'GPIO': {
                'heat_pin': {
                    'required': True
                },
                'cool_pin': {
                    'required': True
                },
            },
            'behavior': {
                'hysteresis': {
                    'required': False,
                    'default': 0.6
                }
            },
            'flask': {
                'port': {
                    'required': True
                },
                'debug': {
                    'required': False,
                    'default': False
                },
                'secret_key': {
                    'required': True
                },
                'public_api_secret': {
                    'required': True
                },
                'username': {
                    'required': True
                },
                'password': {
                    'required': True
                }
            },
            'wunderground': {
                'api_key': {
                    'required': True
                }
            },
            'google': {
                'api_key': {
                    'required': True
                }
            },
            'config': {
                'location': {
                    'required': False
                },
                'location_label': {
                    'required': False
                },
                'celsius': {
                    'required': False,
                    'default': True
                },
                'modes_available': {
                    'required': False,
                    'default': [[Mode.Heat.name, True],
                                [Mode.Cool.name, False]]
                },
                'set_temperature': {
                    'required': False,
                    'default': 21
                },
                'modes': {
                    'required': False,
                    'default': [Mode.Off.name, Mode.Heat.name]
                },
                'mode_set': {
                    'required': False,
                    'default': Mode.Off.name
                }
            },
            'daemon': {
                'pid_file': {
                    'required': True
                },
                'log_file': {
                    'required': True
                },
                'work_dir': {
                    'required': True
                }
            },
            'schedule': {
                'poll_interval': {
                    'required': False,
                    'default': 300
                },
                'db': {
                    'required': True
                },
                'rpc_host': {
                    'required': False,
                    'default': 'localhost'
                },
                'rpc_port': {
                    'required': False,
                    'default': 49152
                }
            }
        }
        if self._is_valid():
            return
        else:
            raise ConfigError(
                'Error: incomplete configuration, please verify '
                'config.yaml settings.'
            )

    def get_config(self):
        with open(self._CONFIG, 'r') as f:
            return yaml.load(f)

    def get_schema(self, section):
        return self._SCHEMA[section]

    def get_version(self):
        return self._SCHEMA_VERSION

    def update_config(self, new_cfg, cfg=None):
        if cfg is None:
            cfg = self.get_config()
        for setting in new_cfg:
            if setting == 'modes_available':
                cfg['config']['modes'] = self.list_modes(new_cfg[setting])
            cfg['config'][setting] = new_cfg[setting]

        return self._is_valid(config=cfg)

    def set_temp(self, temp, scale, cfg=None):
        if cfg is None:
            cfg = self.get_config()

        new_cfg = cfg['config']
        scale = scale.upper()

        if scale == 'C':
            new_cfg['set_temperature'] = temp
        elif scale == 'F':
            # The following conversion duplicates the logic in nido.js
            celsius_temp = (temp - 32) * 5 / 9
            celsius_temp = round(celsius_temp * 10) / 10
            celsius_temp = float("{0:.1f}".format(celsius_temp))
            new_cfg['set_temperature'] = celsius_temp

        return self.update_config(new_cfg, cfg=cfg)

    def set_mode(self, mode, cfg=None):
        if cfg is None:
            cfg = self.get_config()

        new_cfg = cfg['config']
        modes = self.list_modes(cfg['config']['modes_available'])

        for m in modes:
            if m.upper() == mode.upper():
                new_cfg['mode_set'] = m
                return self.update_config(new_cfg, cfg=cfg)

        return False

    def _set_config(self, config):
        with open(self._CONFIG, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, indent=4)
        return

    def _is_valid(self, config=None, set_defaults=True, update=True):
        if config is None:
            config = self.get_config()

        # Iterate through schema and check required flag against
        # loaded config
        schema = self._SCHEMA
        for section in schema:
            for setting in schema[section]:
                if schema[section][setting]['required'] is True:
                    if section not in config:
                        return False
                    elif setting not in config[section]:
                        return False
                # If setting is not required, check if a default value
                #   exists and set it if not set in the config.
                elif (set_defaults and 'default'
                      in schema[section][setting]):
                    if section not in config:
                        default_setting = {
                            section: {
                                setting: schema[section][setting]['default']
                            }
                        }
                        config.update(default_setting)
                    elif setting not in config[section]:
                        config[section][setting] = (
                            schema[section][setting]['default']
                        )

        if update:
            self._set_config(config)
        return True

    @staticmethod
    def list_modes(modes_available):
        modes = [Mode.Off.name]
        heat = False
        cool = False

        for mode in modes_available:
            if mode[1] is True:
                if mode[0] == Mode.Heat.name:
                    heat = True
                elif mode[0] == Mode.Cool.name:
                    cool = True
                modes.append(mode[0])
        if heat and cool:
            modes.append(Mode.Heat_Cool.name)
        return modes
