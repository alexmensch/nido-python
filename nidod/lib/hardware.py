#   Nido, a Raspberry Pi-based home thermostat.
#
#   Copyright (C) 2016 Alex Marshall
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.
#   If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals
from __future__ import print_function
from future import standard_library
standard_library.install_aliases()
from builtins import *
from builtins import str
from builtins import object

import yaml
import os
import logging

from nidod.config import Mode, Status

if 'NIDO_TESTING' in os.environ:
    from nidod.lib.testing import FakeGPIO, FakeSensor as BME280
    GPIO = FakeGPIO(os.environ['NIDO_TESTING_GPIO'])
    BME280_OSAMPLE_8 = None
else:
    import RPi.GPIO as GPIO
    from nidod.lib.Adafruit_BME280 import BME280, BME280_OSAMPLE_8

_NIDO_BASE = os.environ['NIDO_BASE']


class Sensor(object):
    def __init__(self, mode=BME280_OSAMPLE_8):
        try:
            self.sensor = BME280(mode)
        except OSError:
            self.sensor = None
        self._l = logging.getLogger(__name__)
        return None

    def get_conditions(self):
        # Initialize response dict
        resp = {}

        # Could not connect to sensor
        if self.sensor is None:
            resp['error'] = 'Sensor was not detected.'
            return resp

        # Get sensor data
        try:
            temp_c = self.sensor.read_temperature()
            pressure_mb = self.sensor.read_pressure() / 100
            relative_humidity = self.sensor.read_humidity()
            self._l.debug(
                'Sensor data: T = {}C | P = {} | RH = {}'
                .format(temp_c, pressure_mb, relative_humidity)
            )
        except Exception as e:
            resp['error'] = (
                'Exception getting sensor data: {} {}'.format(type(e), str(e))
            )
        else:
            conditions = {
                'temp_c': temp_c,
                'pressure_mb': pressure_mb,
                'relative_humidity': relative_humidity
            }
            resp['conditions'] = conditions

        return resp


class ControllerError(Exception):
    """Exception class for errors generated by the controller"""

    def __init__(self, msg):
        self.msg = msg
        return

    def __str__(self):
        return repr(self.msg)


class Controller(object):
    """This is the controller code that determines whether the
    heating / cooling system should be enabled based on the thermostat
    set point."""

    def __init__(self):
        self._l = logging.getLogger(__name__)
        try:
            self.cfg = Config()
            config = self.cfg.get_config()
        except IOError as e:
            raise ControllerError(
                'Error getting configuration: {}'.format(str(e))
            )
        else:
            self._HEATING = config['GPIO']['heat_pin']
            self._COOLING = config['GPIO']['cool_pin']

        # Set up the GPIO pins
        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self._HEATING, GPIO.OUT)
        GPIO.setup(self._COOLING, GPIO.OUT)
        self._l.debug(
            'GPIO pins configured: heat = {} | cool = {}'
            .format(self._HEATING, self._COOLING)
        )

        return

    def get_status(self):
        if (GPIO.input(self._HEATING) and GPIO.input(self._COOLING)):
            self._l.error('** Both heating and cooling pins enabled. **')
            self.shutdown()
            raise ControllerError(
                'Both heating and cooling pins were enabled. '
                'Both pins disabled as a precaution.'
            )
        elif GPIO.input(self._HEATING):
            self._l.debug('Get status: {}'.format(Status.Heating.name))
            return Status.Heating.value
        elif GPIO.input(self._COOLING):
            self._l.debug('Get state: {}'.format(Status.Cooling.name))
            return Status.Cooling.value
        else:
            self._l.debug('Get state: {}'.format(Status.Off.name))
            return Status.Off.value

    def _enable_heating(self, status, temp, set_temp, hysteresis):
        if (temp + hysteresis) < set_temp:
            GPIO.output(self._HEATING, True)
            GPIO.output(self._COOLING, False)
            self._l.debug(
                'Enabled HEAT: {} < {}'.format(temp + hysteresis, set_temp)
            )
        elif (temp < set_temp) and (status is Status.Heating):
            GPIO.output(self._HEATING, True)
            GPIO.output(self._COOLING, False)
            self._l.debug(
                'Enabled HEAT: {} < {} and status = Heating'
                .format(temp, set_temp)
            )
        return

    def _enable_cooling(self, status, temp, set_temp, hysteresis):
        if (temp + hysteresis) > set_temp:
            GPIO.output(self._HEATING, False)
            GPIO.output(self._COOLING, True)
        elif (temp > set_temp) and (status is Status.Cooling):
            GPIO.output(self._HEATING, False)
            GPIO.output(self._COOLING, True)
        return

    def shutdown(self):
        GPIO.output(self._HEATING, False)
        GPIO.output(self._COOLING, False)
        self._l.debug('Shut down GPIO pins.')
        return

    def update(self):
        config = self.cfg.get_config()
        try:
            mode = config['config']['mode_set']
            status = self.get_status()
            temp = Sensor().get_conditions()['conditions']['temp_c']
            set_temp = float(config['config']['set_temperature'])
            hysteresis = config['behavior']['hysteresis']
        except KeyError as e:
            self.shutdown()
            raise ControllerError('Error reading Nido configuration: {}'
                                  .format(e))
        except ControllerError:
            self.shutdown()
            raise

        if mode == Mode.Off.name:
            self._l.debug('Mode = Off | Set temp {}C'.format(set_temp))
            self.shutdown()
        elif mode == Mode.Heat.name:
            self._l.debug('Mode = Heat | Set temp {}C'.format(set_temp))
            if temp < set_temp:
                self._enable_heating(status, temp, set_temp, hysteresis)
            else:
                self.shutdown()
        else:
            # Additional modes can be enabled in future, eg. Mode.Cool,
            # Mode.Heat_Cool
            self.shutdown()

        return

    def daemon_running(self):
        pid_file = self.cfg.get_config()['daemon']['pid_file']
        return os.path.isfile(pid_file)


class ConfigError(Exception):
    """Exception class for errors generated by the Config class"""

    def __init__(self, msg):
        self.msg = msg
        return

    def __str__(self):
        return repr(self.msg)


class Config(object):
    def __init__(self):
        self._CONFIG = '{}/nido/cfg/config.yaml'.format(_NIDO_BASE)
        self._SCHEMA_VERSION = '1.3'
        self._SCHEMA = {
            'GPIO': {
                'heat_pin': {
                    'required': True
                },
                'cool_pin': {
                    'required': True
                },
            },
            'behavior': {
                'hysteresis': {
                    'required': False,
                    'default': 0.6
                }
            },
            'flask': {
                'port': {
                    'required': True
                },
                'debug': {
                    'required': False,
                    'default': False
                },
                'secret_key': {
                    'required': True
                },
                'public_api_secret': {
                    'required': True
                },
                'username': {
                    'required': True
                },
                'password': {
                    'required': True
                }
            },
            'wunderground': {
                'api_key': {
                    'required': True
                }
            },
            'google': {
                'api_key': {
                    'required': True
                }
            },
            'config': {
                'location': {
                    'required': False
                },
                'location_label': {
                    'required': False
                },
                'celsius': {
                    'required': False,
                    'default': True
                },
                'modes_available': {
                    'required': False,
                    'default': [[Mode.Heat.name, True],
                                [Mode.Cool.name, False]]
                },
                'set_temperature': {
                    'required': False,
                    'default': 21
                },
                'modes': {
                    'required': False,
                    'default': [Mode.Off.name, Mode.Heat.name]
                },
                'mode_set': {
                    'required': False,
                    'default': Mode.Off.name
                }
            },
            'daemon': {
                'pid_file': {
                    'required': True
                },
                'log_file': {
                    'required': True
                },
                'work_dir': {
                    'required': True
                }
            },
            'schedule': {
                'poll_interval': {
                    'required': False,
                    'default': 300
                },
                'db': {
                    'required': True
                },
                'rpc_host': {
                    'required': False,
                    'default': 'localhost'
                },
                'rpc_port': {
                    'required': False,
                    'default': 49152
                }
            }
        }
        if self._is_valid():
            return
        else:
            raise ConfigError(
                'Error: incomplete configuration, please verify '
                'config.yaml settings.'
            )

    def get_config(self):
        with open(self._CONFIG, 'r') as f:
            return yaml.load(f)

    def get_schema(self, section):
        return self._SCHEMA[section]

    def get_version(self):
        return self._SCHEMA_VERSION

    def update_config(self, new_cfg, cfg=None):
        if cfg is None:
            cfg = self.get_config()
        for setting in new_cfg:
            if setting == 'modes_available':
                cfg['config']['modes'] = self.list_modes(new_cfg[setting])
            cfg['config'][setting] = new_cfg[setting]

        return self._is_valid(config=cfg)

    def set_temp(self, temp, scale, cfg=None):
        if cfg is None:
            cfg = self.get_config()

        new_cfg = cfg['config']
        scale = scale.upper()

        if scale == 'C':
            new_cfg['set_temperature'] = temp
        elif scale == 'F':
            # The following conversion duplicates the logic in nido.js
            celsius_temp = (temp - 32) * 5 / 9
            celsius_temp = round(celsius_temp * 10) / 10
            celsius_temp = float("{0:.1f}".format(celsius_temp))
            new_cfg['set_temperature'] = celsius_temp

        return self.update_config(new_cfg, cfg=cfg)

    def set_mode(self, mode, cfg=None):
        if cfg is None:
            cfg = self.get_config()

        new_cfg = cfg['config']
        modes = self.list_modes(cfg['config']['modes_available'])

        for m in modes:
            if m.upper() == mode.upper():
                new_cfg['mode_set'] = m
                return self.update_config(new_cfg, cfg=cfg)

        return False

    def _set_config(self, config):
        with open(self._CONFIG, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, indent=4)
        return

    def _is_valid(self, config=None, set_defaults=True, update=True):
        if config is None:
            config = self.get_config()

        # Iterate through schema and check required flag against
        # loaded config
        schema = self._SCHEMA
        for section in schema:
            for setting in schema[section]:
                if schema[section][setting]['required'] is True:
                    if section not in config:
                        return False
                    elif setting not in config[section]:
                        return False
                # If setting is not required, check if a default value
                #   exists and set it if not set in the config.
                elif (set_defaults and 'default'
                      in schema[section][setting]):
                    if section not in config:
                        default_setting = {
                            section: {
                                setting: schema[section][setting]['default']
                            }
                        }
                        config.update(default_setting)
                    elif setting not in config[section]:
                        config[section][setting] = (
                            schema[section][setting]['default']
                        )

        if update:
            self._set_config(config)
        return True

    @staticmethod
    def list_modes(modes_available):
        modes = [Mode.Off.name]
        heat = False
        cool = False

        for mode in modes_available:
            if mode[1] is True:
                if mode[0] == Mode.Heat.name:
                    heat = True
                elif mode[0] == Mode.Cool.name:
                    cool = True
                modes.append(mode[0])
        if heat and cool:
            modes.append(Mode.Heat_Cool.name)
        return modes
