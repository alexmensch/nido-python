from enum import Enum
import RPi.GPIO as GPIO
from CollectData import Sensor
from NidoConstants import Mode, Status
from NidoConfig import NidoConfig

class ControllerError(Exception):
    """Exception class for errors generated by the controller"""

    def __init__(self, msg):
        self.msg = msg
        return

# TODO: Record start/stop times for all heating/cooling events
class NidoController():
    """This is the controller code that determines whether the heating / cooling system
    should be enabled based on the thermostat set point."""

    def __init__(self):
        # Get Nido configuration
        try:
            self.cfg = NidoConfig()
            config = self.cfg.get_config()
        except:
            raise
        else:
            self._HEATING = config['GPIO']['heat_pin']
            self._COOLING = config['GPIO']['cool_pin']

        # Set up the GPIO pins
        try:
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self._HEATING, GPIO.OUT)
            GPIO.setup(self._COOLING, GPIO.OUT)
        except:
            raise

        return

    @staticmethod
    def get_status():
        if (GPIO.input(self._HEATING) and GPIO.input(self._COOLING)):
            self._shutdown()
            raise ControllerError('Both heating and cooling pins were enabled. Both pins disabled as a precaution.')
        elif GPIO.input(self._HEATING):
            return Status.heating.value
        elif GPIO.input(self._COOLING):
            return Status.cooling.value
        else:
            return Status.off.value

    @staticmethod
    def _enable_heating(status, temp, set_temp, hysteresis):
        if ( (temp + hysteresis) < set_temp ):
            GPIO.output(self._HEATING, True)
            GPIO.output(self._COOLING, False)
        elif ( (temp < set_temp) and (status is Status.heating) ):
            GPIO.output(self._HEATING, True)
            GPIO.output(self._COOLING, False)
        return
    
    @staticmethod
    def _enable_cooling(status, temp, set_temp, hysteresis):
        if ( (temp + hysteresis) > set_temp ):
            GPIO.output(self._HEATING, False)
            GPIO.output(self._COOLING, True)
        elif ( (temp > set_temp) and (status is Status.cooling) ):
            GPIO.output(self._HEATING, False)
            GPIO.output(self._COOLING, True)
        return
    
    @staticmethod
    def _shutdown():
        GPIO.output(self._HEATING, False)
        GPIO.output(self._COOLING, False)
        return

    def update(self):
        try:
            config = self.cfg.get_config()
        except:
            raise
        else:
            try:
                mode = config['settings']['mode']
                status = self.get_status()
                temp = Sensor.get_conditions()['conditions']['temp_c']
                set_temp = config['settings']['set_temperature']
                hysteresis = config['behavior']['hysteresis']
            except KeyError as e:
                self._shutdown()
                raise ControllerError('Encountered KeyError getting current Nido status: {}'.format(e))
            except:
                self._shutdown()
                raise

        if mode is Mode.off:
            self._shutdown()
        elif mode is Mode.heat:
            if temp < set_temp:
                self._enable_heating(status, temp, set_temp, hysteresis)
            else:
                self._shutdown()
        else:
            # Additional modes can be enabled in future, eg. Mode.cool, Mode.heat_cool
            self._shutdown()

        return
