#   Nido, a Raspberry Pi-based home thermostat.
#
#   Copyright (C) 2016 Alex Marshall
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

import rpyc
import json
from functools import wraps
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.date import DateTrigger
from Nido import Config, Controller

class NidoSchedulerService(rpyc.Service):
    """Service class that is exposed via RPC.

    Methods act on the APScheduler service that is initialized on daemon startup.
    Static functions in the class are be passed into scheduler jobs as resulting actions.

    Adapted from: https://github.com/agronholm/apscheduler/blob/master/examples/rpc/server.py
    """

    def __init__(self, scheduler):
        self._scheduler = scheduler

    def __call__(self, conn):
        return self.__class__(self._scheduler)

    def exposed_add_job(self, func, *args, **kwargs):
        return self._scheduler.add_job(func, *args, **kwargs)

    def exposed_modify_job(self, job_id, jobstore=None, **changes):
        return self._scheduler.modify_job(job_id, jobstore, **changes)

    def exposed_reschedule_job(self, job_id, jobstore=None, trigger=None, **trigger_args):
        return self._scheduler.reschedule_job(job_id, jobstore, trigger, **trigger_args)

    def exposed_pause_job(self, job_id, jobstore=None):
        return self._scheduler.pause_job(job_id, jobstore)

    def exposed_resume_job(self, job_id, jobstore=None):
        return self._scheduler.resume_job(job_id, jobstore)

    def exposed_remove_job(self, job_id, jobstore=None):
        self._scheduler.remove_job(job_id, jobstore)

    def exposed_get_job(self, job_id):
        return self._scheduler.get_job(job_id)

    def exposed_get_jobs(self, jobstore=None):
        return self._scheduler.get_jobs(jobstore)

    @staticmethod
    def set_temp(temp, scale):
        return Config().set_temp(temp, scale)

    @staticmethod
    def set_mode(mode):
        return Config().set_mode(mode)

    @staticmethod
    def wakeup():
        Controller().update()
        return

def keepalive(func):
    """Decorator to ensure that RPC connection is active when calls are made.

    The output is converted to JSON if the instance variable self._json is True.
    The base methods return either a Job object or a list of Job objects from
    the APScheduler package."""

    @wraps(func)
    def check_connection(self, *args, **kwargs):
        try:
            result = func(self, *args, **kwargs)
        except EOFError:
            self._connect()
            result = func(self, *args, **kwargs)

        if self._json:
            if isinstance(result, list):
                return self._jsonify(*result)
            else:
                return self._jsonify(result)
        else:
            return result

    return check_connection

class NidoDaemonServiceError(Exception):
    """Exception class for errors generated by the daemon RPC service."""

    def __init__(self, msg):
        self.msg = msg
        return

    def __str__(self):
        return repr(self.msg)

class NidoDaemonService:
    """Wrapper service to view/add/modify/delete daemon scheduler jobs via RPC."""

    def __init__(self, json=False):
        self._json = json
        self._config = Config().get_config()
        self._connect()
        return

    @keepalive
    def wakeup(self):
        return self._connection.root.add_job('nidod:NidoSchedulerService.wakeup')

    @keepalive
    def add_scheduled_job(self, type, day_of_week=None, hour=None, minute=None, job_id=None, mode=None, temp=None, scale=None):
        if type == 'mode':
            return self._connection.root.add_job('nidod:NidoSchedulerService.set_mode', args=[mode], name='Mode', jobstore='schedule', id=job_id, trigger='cron', day_of_week=day_of_week, hour=hour, minute=minute)
        elif type == 'temp':
            return self._connection.root.add_job('nidod:NidoSchedulerService.set_temp', args=[temp, scale], name='Temp', jobstore='schedule', id=job_id, trigger='cron', day_of_week=day_of_week, hour=hour, minute=minute)
        else:
            raise NidoDaemonServiceError('Invalid job type specified: {}'.format(type))

    @keepalive
    def modify_scheduled_job(self, job_id, type, mode=None, temp=None, scale=None):
        if type == 'mode':
            return self._connection.root.modify_job(job_id, args=[mode])
        elif type == 'temp':
            return self._connection.root.modify_job(job_id, args=[temp, scale])
        else:
            raise NidoDaemonServiceError('Invalid job type specified: {}'.format(type))

    @keepalive
    def reschedule_job(self, job_id, day_of_week=None, hour=None, minute=None):
        return self._connection.root.reschedule_job(job_id, trigger='cron', day_of_week=day_of_week, hour=hour, minute=minute)

    @keepalive
    def pause_scheduled_job(self, job_id):
        return self._connection.root.pause_job(job_id)

    @keepalive
    def resume_scheduled_job(self, job_id):
        return self._connection.root.resume_job(job_id)

    @keepalive
    def remove_scheduled_job(self, job_id):
        return self._connection.root.remove_job(job_id)

    @keepalive
    def get_scheduled_jobs(self, jobstore=None):
        return self._connection.root.get_jobs(jobstore=jobstore)

    @keepalive
    def get_scheduled_job(self, job_id):
        return self._connection.root.get_job(job_id)

    def _is_connected(self):
        return not self._connection.closed

    def _connect(self):
        self._connection = rpyc.connect(self._config['schedule']['rpc_host'], self._config['schedule']['rpc_port'], config={'allow_public_attrs': True})

    @staticmethod
    def _jsonify(*args):
        response = {}
        for j in args:
            if j is None:
                pass
            if isinstance(j.trigger, DateTrigger):
                trigger = {
                    'timezone': str(j.trigger.run_date.tzinfo)
                }
            else:
                trigger_start_date = j.trigger.start_date.strftime('%m/%d/%Y %H:%M:%S') if j.trigger.start_date else None
                trigger_end_date = j.trigger.end_date.strftime('%m/%d/%Y %H:%M:%S') if j.trigger.end_date else None
                trigger = {
                    'start_date': trigger_start_date,
                    'end_date': trigger_end_date,
                    'timezone': str(j.trigger.timezone)
                }

            if isinstance(j.trigger, CronTrigger):
                trigger['cron'] = {}
                for f in j.trigger.fields:
                    trigger['cron'][f.name] = str(f)
            elif isinstance(j.trigger, IntervalTrigger):
                trigger_interval = str(j.trigger.interval) if j.trigger.interval else None
                trigger['interval'] = trigger_interval
            elif isinstance(j.trigger, DateTrigger):
                trigger['run_date'] = j.trigger.run_date.strftime('%m/%d/%Y %H:%M:%S')
            else:
                raise NidoDaemonServiceError('Unknown trigger type: {}'.format(type(j.trigger)))

            job = {
                'name': j.name,
                'args': j.args,
                'next_run_time': j.next_run_time.strftime('%m/%d/%Y %H:%M:%S'),
                'trigger': trigger
            }
            
            response[j.id] = job
        if len(response.keys()) == 0:
            response['warning'] = 'Either no jobs are scheduled, or the job ID supplied does not exist.'
        return response
